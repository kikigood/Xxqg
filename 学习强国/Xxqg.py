# Generated by Selenium IDE
import pytest
import time
import json
import os
import time
import random
import unittest
import pickle
from pickle import UnpicklingError
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.common.action_chains import ActionChains
from selenium.webdriver.support import expected_conditions
from selenium.webdriver.support.wait import WebDriverWait
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.common.desired_capabilities import DesiredCapabilities
from selenium.webdriver.support import expected_conditions as EC
from selenium.common.exceptions import NoSuchElementException,TimeoutException,ElementClickInterceptedException
from printQrcode import printQrcode

import threading
import datetime


'''
配置信息

'''
# 每exeTime执行一次程序
exeTime=60*60*12
# 隐藏执行（隐藏浏览器执行可能造成阅读不增加积分）
addArgs='--headless'
# 页面响应等待时间
wait_time=30
# 观看视频数量
movies_num=10
# 每个视频观看时间s
movie_time=61*6
# 读文章的数量
articles_num=5
# 没票文章读的时间s
article_time=61*8

# 火狐浏览器路径，空为默认安装路径
# firefoxPath="C:/Program Files/Mozilla Firefox/firefox.exe"
# firefoxPath=""
firefoxPath="C:/Program Files/Mozilla Firefox/firefox.exe"

def saveCookies(cookies):
  with open('xxqg_cookies.pkl','wb') as f:
    pickle.dump(cookies, f)
    print("更新cookies成功")

def getCookies():
  try:
    with open("xxqg_cookies.pkl", "rb") as f:

      cookies = pickle.load(f)
      for cookie in cookies: 
          if isinstance(cookie.get('expiry'), float):
              cookie['expiry'] = int(cookie['expiry'])
      # print(cookies)
      return cookies
  except (FileNotFoundError,EOFError,UnpicklingError) as msg:
    return None
  return None


class Test_1(unittest.TestCase):
  
  def setUp(self):
    self.option=webdriver.FirefoxOptions()
    self.option.add_argument(addArgs)

    if firefoxPath!="":
      self.option.binary_location=firefoxPath
    if os.name=='nt':
      ser=webdriver.firefox.service.Service(os.getcwd()+"/driver/win32/geckodriver.exe")
    elif os.name=='posix':
      ser=webdriver.firefox.service.Service(os.getcwd()+"/driver/linux64\geckodriver")
    else:
      print("暂不支持")
      
    print("当前浏览器路径：",firefoxPath)
    print("当前驱动路径：",ser.path)

    self.driver = webdriver.Firefox(options=self.option,service=ser)
    
    self.vars = {}
  
  def tearDown(self):
    self.driver.quit()
    
  def wait_for_window(self, timeout = 2):
    time.sleep(round(timeout / 1000))
    wh_now = self.driver.window_handles
    wh_then = self.vars["window_handles"]
    # print("现在：",wh_now)
    # print("之前：",wh_then)
    if len(wh_now) > len(wh_then):
      return set(wh_now).difference(set(wh_then)).pop()
  
  def click_to_new_window(self,newName,oldName,locator=None,closeOld=False,element=None):
    '''
        点击打开新的窗口
        str newName:新窗口的名字
        str oldName:旧窗口的名字
        元组 locator:点击事件定位【例：(By.CSS_SELECTOR, ".login-icon")】
        bool closeOld:False不关闭旧窗口
        element 点击的目标
    
    '''
    # 保存已经打开了的窗口1
    self.vars["window_handles"] = self.driver.window_handles
    # 保存旧的窗口
    self.vars[oldName] = self.driver.current_window_handle


    if element==None:#未指定点击element
      self.wait_for_element(locator)
      self.driver.find_element(locator[0],locator[1]).click()
    else:
      element.click()
      
    #保存新的窗口
    self.vars[newName] = self.wait_for_window(2000)
    
    if closeOld:
      self.driver.switch_to.window(self.vars[oldName])
      self.driver.close()
      self.vars.pop(oldName)
    self.driver.switch_to.window(self.vars[newName])
      
    return True
  def click_to_window(self,newName,oldName,element,t=2000):
    '''
    点击变为新窗口
    '''
    time.sleep(t/1000)
    element.click()
    self.vars[newName] = self.driver.current_window_handle
    self.vars.pop(oldName)
    self.driver.switch_to.window(self.vars[newName])
    
  def back(self,newName,oldName):
    '''
    返回上级页面
    '''
    self.driver.back()
    self.vars[newName] = self.driver.current_window_handle
    self.vars.pop(oldName)
    self.driver.switch_to.window(self.vars[newName])
    
  def login(self):
    '''
    登录页面
    入口为：https://pc.xuexi.cn/points/login.html
    出口为：https://pc.xuexi.cn/points/my-points.html
    '''
    
     # 点击登录
    self.click_to_new_window("loginPage","rootPage",(By.CSS_SELECTOR, ".login-icon"),True)
    #Get Login Qrcode
    self.driver.switch_to.frame("ddlogin-iframe")
    
    self.wait_for_element((By.CLASS_NAME ,"login_qrcode_content"))
      
    qrcode_base64=self.driver.find_element(By.CLASS_NAME ,"login_qrcode_content").find_element(By.TAG_NAME,"img").get_attribute("src").replace("data:image/png;base64,", "")
    printQrcode(qrcode_base64) 
    # 登录并进入个人home页面
    try:
      print("你有一分钟的时间登录。")   
      element = WebDriverWait(self.driver,wait_time).until(
          EC.url_to_be("https://pc.xuexi.cn/points/my-points.html")
      )
      print("Login Success!")
      # print(self.driver.title)
      self.vars["homePage"] = self.driver.current_window_handle
      self.vars.pop("loginPage")
      self.driver.switch_to.window(self.vars["homePage"])
    except TimeoutException as msg:
      print("Login Fall.",msg)
      return False
    return True
      
  def readArticles(self,elements):
    '''
    读文章
    入口为：https://www.xuexi.cn/
    出口为：https://www.xuexi.cn/
    
    '''
    self.click_to_window("articlePointPage","homePage",elements.find_element(By.CLASS_NAME,"big"))

    #Choose one random Article to get point.
    try:
      WebDriverWait(self.driver,wait_time).until(
          EC.presence_of_element_located((By.CLASS_NAME,"text-link-item-title"))
      )
    except:
      print("Fall") 
    arts=self.driver.find_elements(By.CLASS_NAME,"text-link-item-title")
    
    # Read last 5 Articles
    for art in arts[:articles_num]:#读文章的篇数
      movies=[]
      vedio=[]
      print("【正在阅读】>>"+art.text)
      self.click_to_new_window("readingArtPage", "ArtsPage",element=art) 
      self.wait_for_element((By.CLASS_NAME,"xuexi"))
      
      time.sleep(3)
      if not self.chick_err():#如果系统没有错误
        # 这里可以添加播报
        time.sleep(random.randint(article_time//2, 3*article_time//2))

        print("【本文结束】","\n=======================")
        
      self.driver.close()
      self.driver.switch_to.window(self.vars["ArtsPage"])

  
    
  def wait_for_element(self,locator,msgs=""):
    #等待点击目标出现
    try:
        element = WebDriverWait(self.driver,wait_time).until(
        EC.presence_of_element_located(locator)
    )
    except TimeoutException as msg:
        print("【错误】：",msg,'\n'+msgs)
        return False 
    time.sleep(1)
    return True

  def watchMovies(self):
    '''
    看视频入口为：https://www.xuexi.cn/
    返回页面为：https://www.xuexi.cn/
    
    '''
    self.wait_for_element((By.CSS_SELECTOR,".tab-item.active.center-item"))
    pingdao=self.driver.find_elements(By.CSS_SELECTOR,".tab-item.active.center-item")[0]
    # 进入第一频道
    self.click_to_new_window("moviesPage", "ArtsPage",element=pingdao)
    #innerPic
    self.wait_for_element((By.CLASS_NAME,"innerPic"))
    movies=self.driver.find_elements(By.CLASS_NAME,"innerPic")
    
    # 随机看5个视频
    for i in range(movies_num):#观看视频数
        # 随机选择一个观看
        r=random.randint(0, len(movies)-1)
        print("【正在播放】",i+1)
        self.click_to_new_window("watchingPage", "moviesPage",element=movies[r])
        # 点击播放视频
        self.chick_err()
        self.wait_for_element((By.CSS_SELECTOR,"prism-big-play-btn"))
        try:
            element=self.driver.find_element(By.CLASS_NAME,"prism-big-play-btn").find_element(By.TAG_NAME,"div")
            
            element.click()
        except NoSuchElementException as msg:
            print("播放失败")
        
        # 视频播放时间
        time.sleep(movie_time)
        self.driver.close()
        self.driver.switch_to.window(self.vars["moviesPage"])
        print("【播放结束】")
    # 回到首页
    self.driver.close()
    self.driver.switch_to.window(self.vars["ArtsPage"])
    
  def chick_err(self):
        # 如果页面维护
        self.wait_for_element((By.CLASS_NAME,"xuexi"))
        err=False
        try:
            for i in range(3):
                EC.presence_of_element_located((By.XPATH,r'//*[@id="root"]/div/section/div/div/div/div/div/div/div/h1'))(self.driver)
                self.driver.refresh()
        except NoSuchElementException as msg:
            time.sleep(3)
            return False
        return True
  def chick_login(self):
    cookies=getCookies()
    if cookies==None:
      self.driver.get("https://pc.xuexi.cn/points/login.html")
      self.driver.set_window_size(1721, 927)
      self.driver.switch_to.frame(0)
      self.login()
      self.cookies=self.driver.get_cookies()
      saveCookies(self.cookies)
    else:
      self.driver.get("https://pc.xuexi.cn/points/my-points.html")
      for cookie in cookies:
        self.driver.add_cookie(cookie)
      self.driver.get("https://pc.xuexi.cn/points/my-points.html")
      self.driver.set_window_size(1721, 927)
      self.vars["homePage"] = self.driver.current_window_handle

      
        
      
  def test_1(self):

    self.chick_login()
    # # 检索获取积分选项
    self.wait_for_element((By.CLASS_NAME,"my-points-card"),"建议解决方式：删除Cookie重新登录")
    
    # 读文章，完成后返回个人积分页面
    point_items=self.driver.find_element(By.CLASS_NAME,"my-points-content").find_elements(By.CLASS_NAME,"my-points-card")
    self.readArticles(point_items[1])
    # 读完文章更新一下cookies
    self.cookies=self.driver.get_cookies()
    saveCookies(self.cookies)
    # 刷视频
    self.watchMovies()
    # 退出
    self.driver.quit()




def func_timer():

    unittest.main()
    global timer  # 定义全局变量
    # 定时器构造函数主要有2个参数，第一个参数为时间，第二个参数为函数名
    timer = threading.Timer(exeTime, func_timer)   # 10秒调用一次函数

    print("线程名称={},\n正在执行的线程列表:{},\n正在执行的线程数量={},\n当前时间={}\n".format(
        timer.getName(), threading.enumerate(), threading.active_count(),(datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')))
    )

    timer.start()    #启用定时器




if __name__ == '__main__':
  timer = threading.Timer(1, func_timer)
  timer.start()
  print('程序开始')